<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>INK - wiki</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism.css">
  <link rel="stylesheet" href="styles.css"> <!-- External stylesheet for CSS styles -->
</head>
<body>

  <header>
    <h1>INK's Not KAT: Settings Wiki</h1>
    <p>A wiki detailing customizable settings available to users. Raw Lua file: <a href="settings.lua" target="_blank">settings.lua</a></p>
    <p>Note: Currently implementing the parser into the game, expected completion may take some time.</p>
    <p>Update: JSON parser has been added. Syntax highlighting may be updated later, working on a custom parser!</p>
  </header>

  <main>
    <table>
      <caption>Customizable Settings</caption>
      <thead>
        <tr>
          <th><button onclick="sortTable(0)">Name</button></th>
          <th><button onclick="sortTable(1)">Type</button></th>
          <th><button onclick="sortTable(2)">Example</button></th>
          <th><button onclick="sortTable(3)">Description</button></th>
          <th><button onclick="sortTable(4)">Notes</button></th>
          <th><button onclick="sortTable(5)">Version Added</button></th>
        </tr>
      </thead>
      <tbody id="settingsTableBody">
        <!-- Table content will be dynamically generated here -->
      </tbody>
    </table>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/prism.js"></script>

  <script>
    let currentSortColumn = -1;
    let sortAscending = true;

    async function fetchSettingsData() {
      try {
        const response = await fetch('settings.json');
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Error fetching settings data:', error);
        return { settings: [] };
      }
    }

    async function generateTableRows() {
      const settingsData = await fetchSettingsData();
      const tableBody = document.getElementById('settingsTableBody');

      settingsData.settings.forEach(setting => {
        const row = tableBody.insertRow();
        const keys = Object.keys(setting);

        keys.forEach(key => {
          const cell = row.insertCell();

          if (key === 'Example' || key === 'Type') {
            const codeBox = document.createElement('code');
            codeBox.classList.add('language-clike');
            codeBox.textContent = setting[key];
            cell.appendChild(codeBox);
            Prism.highlightElement(codeBox);
          } else {
            cell.textContent = setting[key];
          }
        });
      });
    }

    function sortTable(column) {
      const table = document.querySelector('table');
      const tbody = document.querySelector('tbody');
      const rows = Array.from(tbody.rows);

      if (currentSortColumn === column) {
        sortAscending = !sortAscending;
      } else {
        sortAscending = true;
      }

      rows.sort((a, b) => {
        const aValue = a.cells[column].textContent.trim();
        const bValue = b.cells[column].textContent.trim();

        if (column === 5) {
          return sortAscending ? parseFloat(aValue) - parseFloat(bValue) : parseFloat(bValue) - parseFloat(aValue);
        } else {
          return sortAscending ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
        }
      });

      while (tbody.firstChild) {
        tbody.removeChild(tbody.firstChild);
      }

      rows.forEach(row => {
        tbody.appendChild(row);
      });

      currentSortColumn = column;
    }

    window.onload = function () {
      generateTableRows();
    };
  </script>

</body>
</html>
